# pxl_logic_core.py

from enum import Enum
from typing import Any


class LogicalState(Enum):
    TRUE = 1
    FALSE = 0
    UNKNOWN = -1


class PXLIdentity:
    def __init__(self, label: str):
        self.label = label

    def is_distinct_from(self, other: 'PXLIdentity') -> bool:
        return self.label != other.label

    def __eq__(self, other: Any) -> bool:
        return isinstance(other, PXLIdentity) and self.label == other.label

    def __hash__(self):
        return hash(self.label)

    def __str__(self):
        return f"ID<{self.label}>"


class PXLRelation:
    def __init__(self, source: PXLIdentity, target: PXLIdentity, relation_type: str):
        self.source = source
        self.target = target
        self.relation_type = relation_type

    def is_valid(self) -> bool:
        return self.source != self.target


class PXLLogicCore:
    def __init__(self):
        self.entities = set()
        self.relations = []

    def register_entity(self, label: str) -> PXLIdentity:
        entity = PXLIdentity(label)
        self.entities.add(entity)
        return entity

    def add_relation(self, source: PXLIdentity, target: PXLIdentity, rel_type: str) -> None:
        relation = PXLRelation(source, target, rel_type)
        if relation.is_valid():
            self.relations.append(relation)

    def check_non_contradiction(self, a: PXLIdentity, b: PXLIdentity) -> bool:
        return a != b

    def apply_excluded_middle(self, a: PXLIdentity, proposition: str, state: LogicalState) -> bool:
        return state in (LogicalState.TRUE, LogicalState.FALSE)

    def check_bijective_mirror(self, a: PXLIdentity, b: PXLIdentity, key: str) -> bool:
        return a.is_distinct_from(b) and key in ("coherence", "truth", "existence", "goodness")

    def evaluate_agency(self, observer: PXLIdentity, relation: PXLRelation) -> bool:
        return relation.source == observer or relation.target == observer


# Modal + Privative Extensions

class ModalEvaluator:
    def __init__(self):
        self.possible_worlds = []

    def add_possible_world(self, world_state: dict):
        self.possible_worlds.append(world_state)

    def is_possibly_true(self, proposition: str) -> bool:
        return any(proposition in world for world in self.possible_worlds)

    def is_necessarily_true(self, proposition: str) -> bool:
        return all(proposition in world for world in self.possible_worlds)


class PrivativeConstraint:
    def __init__(self, negated_properties: set):
        self.negated_properties = negated_properties

    def violates_ontology(self, entity: PXLIdentity, property_name: str) -> bool:
        return property_name in self.negated_properties
